console.log("Started")
const tetrominoes =
{
    "L": [ [1,1],[1,2],[1,3],[2,3] ],
    "Z": [ [1,1],[1,2],[2,2],[2,3] ],
    "S": [ [1,2],[1,3],[2,1],[2,2] ],
    "T": [ [1,1],[2,1],[2,2],[3,1] ],
    "O": [ [1,1],[1,2],[2,1],[2,2] ],
    "I": [ [1,1],[1,2],[1,3],[1,4] ]
};

// When a block's position is set add set to the string.
const tetrisDS =
[
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""],
    ["", "", "", "", "", "", "", "", "", ""]
];


function generateStartingPos(coords)
{
    let width = 0;
    for (let i = 0; i < 4; i++)
    {
        if (coords[i][1] > width)
        {
            width = coords[i][1];
        }
    }
    switch (width)
    {
        case 2:
            // width is 2 so shift it 4 blocks to the right
            for (let i = 0; i < 4; i++)
            {
                coords[i][0] -= 1;
                coords[i][1] += 3;
            }
            break;
        case 3:
            // width is 3 so shift it 3 blocks to the right
            for (let i = 0; i < 4; i++)
            {
                coords[i][0] -= 1; // Adjusting coords for 0 index
                coords[i][1] += 3;
            }
            break;
        case 4:
            // width is 4 so shift it 3 blocks to the right
            for (let i = 0; i < 4; i++)
            {
                coords[i][0] -= 1; // Adjusting coords for 0 index
                coords[i][1] += 2;
            }
            break;
    }
    return coords;
}


function moveChecker(potential_coords)
{
    // [ [ x0, y0 ], [ x1, y1 ], [ x2, y2 ], [ x3, y3 ] ]
    let move_possible = true
    for(let i=0; i<4; i++)
    {
        // If statement checks if one of the coordinates doesn't contain a "set" block
        // OR if it isn't within the bounds of the array
        if (potential_coords[i][0] > 19)
        {
            move_possible = false;
            break;
        }
        if (potential_coords[i][1] > 9)
        {
            move_possible = false;
            break;
        }
        if ((tetrisDS[potential_coords[i][0]][potential_coords[i][1]].includes("set")) ||
            (tetrisDS[potential_coords[i][0]][potential_coords[i][1]] === undefined))
        {
            console.log(potential_coords[i][0] + "," + potential_coords[i][1] + "was filled with:");
            console.log(tetrisDS[potential_coords[i][0]][potential_coords[i][1]]);
            move_possible = false;
            break;
        }
    }
    return move_possible;
}


let gamePiece =
{
    Nodes: [],
    coords: [],
    id: "",
    move_y: 0,
    move_x: 0,
    color: "",
    updatePos:
        function(new_coords)
        {
            // Checking move is possible
            if (moveChecker(new_coords))
            {
                // Update the position in the tetrisDS
                for(let i=0; i<4; i++)
                {
                    // Accessing the elements that refer to the old position and setting them to empty.
                    tetrisDS[this.coords[i][0]][this.coords[i][1]] = "";
                }
                for(let i=0; i<4; i++)
                {
                    //  Accessing the elements that refer to the new position and setting them to the id.
                    tetrisDS[new_coords[i][0]][new_coords[i][1]] = this.id;
                }
                this.coords = new_coords
                // Checking if nodes are initialized, if so, change them, else create them.
                if (this.Nodes.length !== 0)
                {
                    // Modifying nodes
                    for(let i=0; i<4; i++)
                    {
                        let x = this.coords[i][1] * 30 + "px";
                        let y = this.coords[i][0] * 30 + "px";
                        if (this.id.includes("set"))
                        {
                            this.Nodes.id = this.id;
                            this.Nodes[i].style.left = x;
                            this.Nodes[i].style.top = y;
                        }
                        else
                        {
                            this.Nodes[i].style.transform = "translate(" + x + ")";
                            this.Nodes[i].style.top = y;
                        }
                    }
                }
                else
                {
                    // Creating nodes, if working right, this only gets called when generateStartingPos is called
                    for(let i=0; i<4; i++)
                    {
                        let block;
                        block = document.createElement("div");
                        block.className = 'block';
                        block.id = this.id;
                        block.style.backgroundColor = this.color;
                        block.style.top =  this.coords[i][0] * 30+  "px";
                        block.style.left = this.coords[i][1] * 30 + "px";
                        this.Nodes.push(block);
                    }
                }
                return true;
            }
            return false;
        },
    moveLat:
        function (LoR)
    {
        // LoR = +1 or -1, +1 would indicate a move to the right and -1 would indicate a move to the right
        let new_coords = [[0,0],[0,0],[0,0],[0,0]]
        for (let i = 0; i < 4; i++)
        {
            new_coords[i][0] = this.coords[i][0];
            new_coords[i][1] = this.coords[i][1] + LoR;
        }
        // Move is made if possible
        return this.updatePos(new_coords);
        },

    moveDown:function(do_nothing=false)
        {
            setTimeout(this.moveDown, 1000)
            if(do_nothing)
            {
                return null;
            }
            // Done so to prevent aliasing
            let new_coords = [[0,0],[0 ,0],[0,0],[0,0]];
            for (let i = 0; i < 4; i++)
            {
                // Changing only the x coordinate.
                new_coords[i][0] = this.coords[i][0] + 1;
                new_coords[i][1] = this.coords[i][1];
            }

            // This means the position wasn't updated. This would happen in 2 cases:
            // One of the blocks hit the bottom, or another block. Same consequence
            const update = this.updatePos(new_coords)
            if (!(update))
            {
                console.log("set");
                this.id += "set";
                return this.updatePos(this.coords);
            }
        }
};


function make_new_gamepiece()
{
    console.log("Started to make piece")
    let piece = gamePiece;
    // Make it pick a random one, empty string is placeholder.
    const tetro_num = Math.floor(Math.random() * 6);
    let tetro = "";
    switch (tetro_num)
    {
        case 0:
            tetro = "L";
            piece.color = 'cyan';
            break;
        case 1:
            tetro = "Z";
            piece.color = "red";
            break;
        case 2:
            tetro = "S";
            piece.color = "green";
            break;
        case 3:
            tetro = "T";
            piece.color = "purple";
            break;
        case 4:
            tetro = "O";
            piece.color = 'yellow';
            break;
        case 5:
            tetro = "I";
            piece.color = 'cyan';
            break;
    }
    piece.id = tetro;
    console.log("Decided to make piece: " + tetro)
    piece.coords = generateStartingPos(tetrominoes[tetro]);
    console.log("Got starting pos: " + piece.coords)
    if(piece.updatePos(piece.coords))
    {
        return piece
    }
    else
    {
        return false
    }
}

let game_ongoing = true;
let currentBlock;
let move_handler;
    const tetris_game = document.getElementById("tetris-game")
    const gP = make_new_gamepiece();
    if (gP === false) {
        // Game ends.
        game_ongoing = false;
        // continue;
    }
    currentBlock = gP.coords;
    // Appending the nodes for the new gamepiece
    for (let i = 0; i < 4; i++) {
        tetris_game.appendChild(gP.Nodes[i])
    }
    console.log("Child NODES")
    console.log(tetris_game.childNodes[1].outerHTML)
    console.log(tetris_game.childNodes[2].outerHTML)
    console.log(tetris_game.childNodes[3].outerHTML)
    console.log(tetris_game.childNodes[4].outerHTML)
    game_ongoing = false
// while (game_ongoing) {
//     const tetris_game = document.getElementById("tetris-game")
//     const gP = make_new_gamepiece();
//     if (gP === false) {
//         // Game ends.
//         game_ongoing = false;
//         continue;
//     }
//     currentBlock = gP.coords;
//     // Appending the nodes for the new gamepiece
//     for (let i = 0; i < 4; i++) {
//         tetris_game.appendChild(gP.Nodes[i])
//     }
//     console.log("Child NODES")
//     console.log(tetris_game.childNodes[1].outerHTML)
//     console.log(tetris_game.childNodes[2].outerHTML)
//     console.log(tetris_game.childNodes[3].outerHTML)
//     console.log(tetris_game.childNodes[4].outerHTML)
//     game_ongoing = false
// }
//     // Loop until the block is set then generates new game piece.
//     while (!gP.id.includes("set"))
//     {
//         move_handler = function(e)
//         {
//             switch (e.key)
//             {
//                 case ("ArrowRight"):
//                     gP.moveLat(1);
//                     break;
//                 case ("ArrowLeft"):
//                     gP.moveLat(-1);
//                     break;
//                 case ("ArrowDown"):
//                     gP.moveDown();
//                     break;
//                 case ("ArrowUp"):
//                     break;
//             }
//         }
//         currentBlock = gP.coords;
//         // This call is simply to make moveDown schedule itself for after a second.
//         gP.moveDown(true);
//         console.log("Before EL" + gP.coords)
//         tetris_game.addEventListener("keydown", move_handler);
//         const search_id = "#" + gP.id;
//         const old_nodes = tetris_game.querySelectorAll(search_id);
//         for (let i =0; i < 4; i++)
//         {
//             // Replace the nodes with new gP.Nodes to reflect the change in position
//             old_nodes[i].replaceWith(gP.Nodes)
//         }
//         tetris_game.removeEventListener("keydown", move_handler);
//     }
//     // Gamepiece is set, then this is executed.
//     // Checking to see if row clearing is needed. CAN BE MADE MORE EFFICIENT BY ONLY CHECKING THE ROWS THAT
//     // THE GAMEPIECE OCCUPIES WHEN SET simply need to change the starter statement of for loop.
//     for(let row=0; row < 20; row++)
//     {
//         let clear_row = true;
//         for(let col=0; col < 10; col++)
//         {
//             if (!tetrisDS[row][col].includes("set"))
//             {
//                 clear_row = false;
//                 break;
//             }
//         }
//         if(clear_row)
//         {
//             tetrisDS.splice(row,1)
//             tetrisDS.unshift(["", "", "", "", "", "", "", "", "", ""])
//             // Note row index will still refer to the nodes you have to change because deleting from the
//             // data structure doesn't change anything about nodes.
//             let search_query = "top=" + row*30 + "px";
//             const nodes_to_delete = tetris_game.querySelectorAll(search_query);
//             for(let n=0; n < 10; n++)
//             {
//                 nodes_to_delete[n].remove();
//             }
//             for(let n=row; n >= 0; n--)
//             {
//                 search_query = "top=" + n*30 + "px";
//                 const nodes_to_shift = tetris_game.querySelectorAll(search_query);
//                 if (nodes_to_shift.length !== 0)
//                 {
//                     // SShifting the nodes as necessary.
//                     nodes_to_shift.forEach((element, index) =>
//                         {
//                             nodes_to_shift[index].style.top = (n + 1) * 30 + "px";
//                         }
//                     );
//                 }
//             }
//         }
//     }
// }



            switch (id)
            {
                case 'L':
                    color = 'cyan';
                    break;
                case 'L-set':
                    color = 'cyan';
                    break;
                case 'Z':
                    color = "red";
                    break;
                case 'Z-set':
                    color = "red";
                    break;
                case 'S':
                    color = "green";
                    break;
                case 'S-set':
                    color = "green";
                    break;
                case 'T':
                    color = "purple";
                    break;
                case 'T-set':
                    color = "purple";
                    break;
                case 'O':
                    color = 'yellow';
                    break;
                case 'O-set':
                    color = 'yellow';
                    break;
                case 'I':
                    color = 'cyan';
                    break;
                case 'I-set':
                    color = 'cyan';
                    break;
            }
